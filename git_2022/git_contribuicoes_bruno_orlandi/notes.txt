ANOTAÇÕES SOBRE O CURSO DE GIT DO BRUNO ORLANDI
=============================================================================================
--- CURSO ---

-> SEM ABORDAGEM TÉCNICA
-> FOCO APRENDIZADO É NA PRÁTICA
-> SEM ENVOLVIMENTO DE CÓDIGO

=============================================================================================
--- CONTEÚDO ---

-> CONTROLE DE VERSÃO
-> COMANDOS BÁSICOS
-> RAMIFICAÇÕES
-> PUBLICANDO E COLABORANDO
-> EXERCÍCIOS
-> EXTRAS

=============================================================================================
--- GIT ---

-> SISTEMA DE CONTROLE DE VERSÃO DISTRIBUÍDO
-> CRIADO POR LINUS TORVALDS (05)

=============================================================================================
--- GERÊNCIA DE CONFIGURAÇÃO DE SOFTWARE ---

	DURANTE O DESENVOLVIMENTO DO SOFTWARE, SEMPRE APARECERÁ ALGUMAS PERGUNTAS QUANDO AS MUDANÇAS FORAM FEITAS. OS SOFTWARES IRÃO SOFRER VÁRIAS ALTERAÇÕES E SABER O QUE FOI MUDANDO, QUANDO FOI MUDADO, PORQUE FOI MUDADO, QUEM FEZ A MUDANÇA E SE ESSA MUDANÇA PODE SER REPRODUZIDA SÃO DÚVIAS E/OU INFORMAÇÕES MUITAS VEZES NECESSÁRIAS PARA A CONTINUAÇÃO DO DESENVOLVIMENTO DO SOFTWARE.

	EXISTEM 4 IMPORTANTES TÓPICOS SOBRE A GERÊNCIA DE CONFIGURAÇÃO DE SOFTWARE QUE MERECEM UMA ATENÇÃO ESPECIAL, SÃO ELES:
	-> IDENTIFICAÇÃO
	-> DOCUMENTAÇÃO
	-> CONTROLE
	-> AUDITORIA

	DURANTE O DESENVOLVIMENTO DE SOFTWARE, O ARTEFATO É PRODUZIDO. E A GERÊNCIA DE CONFIGURAÇÃO DE SOFTWARE DEVE SER APLICADA SOBRE O ARTEFATO. O ARTEFATO É UMA COMPISIÇÃO DESTES TRÊS PRINCIPAIS ITENS:
	-> CÓDIGO FONTE
	-> DOCUMENTAÇÃO DO SOFTWARE
	-> MANUAL DO USUÁRIO

=============================================================================================
--- CONTROLE DE VERSÃO ---

*** EXEMPLO DE PROBLEMA, COMO O DROPBOX ***

*** EXEMPLO DO CONTROLE DE VERSÃO: <VISUALIZE E IMAGEM "CONTROLE_VERSAO.PNG" ***

=============================================================================================
--- GIT E GITHUB ---

PARA NÃO HAVER MAIS CONFUSÃO ENTRE AS DUAS COISAS:
	-> GIT É O SISTEMA DE CONTROLE DE VERSÕES E PODEM ENVIAR/RECEBER ARQUIVOS DE VÁRIOS HUBS.
	-> GITHUB É UM HUB PARA ARMAZENAR OS ARQUIVOS ENVIADOS POR GIT.

	ALGUNS EXEMPLOS DE HUBS QUE SUPORTAM O GIT PARA ENVIO/RECEBIMENTO DE ARQUIVOS:
	-> GITHUB
	-> GITLAB
	-> BITBUCKET
	-> SOURCEFORGE

=============================================================================================
--- CHAVE SSH ---

	A CHAVE SSH DEVE SER CONFIGURADA COMO FORMA DE AUTENTICAÇÃO DIRETA ENTRE O GIT E O HUB ESCOLHIDO. HÁ INÚMERAS CONFIGURAÇÕES QUE PODEM SER FEITAS, INCLUINDO DATA PARA O FIM DA LIBERAÇÃO. CADA HUB TEM CONFIGURAÇÕES E OPÇÕES DIFERENTES, MAS COM UM TUTORIAL COMPLETO.

=============================================================================================
--- COMANDOS GIT ---
	-> GIT INIT
	-> GIT STATUS
	-> GIT ADD .
	-> GIT COMMIT
	-> GIT LOG
	DEPOIS DO RESPOSITÓRIO ABERTO NO GITHUB:
	-> GIT REMOTE ADD ORIGIN <https>
	-> GIT PUSH
	-> CONFIGURAR O README


=============================================================================================
--- CLONE ----

	-> GIT CLONE
	-> GIT PULL

=============================================================================================
--- CHECKOUT ---
	EM ALGUM DETERMINADO MOMENTO, SEU PROJETO JÁ TERÁ MUITOS COMMITS. E EM ALGUM MOMENTO VOCÊ VAI PRECISAR VOLTAR ATRÁS EM UM COMMIT ESPECÍFICO. PARA CONSEGUIR TRAZER QUALQUER COMMIT ESPECÍFICO BASTA UTILIZAR O COMANDO:
	-> GIT CHECKOUT <commit> <file>

	PARA PODER OBTER O CÓDIGO DO COMMIT A SER RECUPERADO, UTILIZE DO GIT LOG PARA VERIFICAR AS INFORMAÇÕES SOBRE O COMMIT. COM O CÓDIGO GERADO, UTILIZE NO EXEMPLO E O RETORNO SERÁ A ATUALIZAÇÃO (NO CASO, RETORNO) PARA OS ARQUIVOS COMO ESTAVAM NAQUELE COMMIT.

	AQUI DUAS SITUAÇÕES PODEM ACONTECER. A UTILIZAÇÃO DESTES CÓDIGO MAIS ANTIGOS EM UMA OUTRA VERSÃO. E COM ESSA IDEIA O GIT SUGERE A CRIAÇÃO DE UMA BRANCH. ESSA OUTRA OPÇÃO, NÓS VEREMOS DEPOIS. PARA AGORA, VAMOS UTILIZAR A OUTRA SITUAÇÃO. NÃO MODIFICAMOS NADA E QUEREMOS VOLTAR PARA A MAIS ATUAL. PARA VOLTAR, BASTA DIGITAR O COMANDO:
	-> GIT CHECKOUT MASTER

	E VOCÊ ESTARÁ DE VOLTA A VERSÃO MAIS ATUAL DO PROJETO.

*** OUTROS COMANDOS UTILIZANDO O GIT CHECKOUT ***

	-> GIT CHECKOUT --<caminho/arquivo>
	ESSE COMANDO IRÁ TE PERMITIR DESFAZER DE TODAS AS ALTERAÇÕES QUE NÃO ESTEJAM NO STAGE (A ALTERAÇÃO ACONTECE QUANDO O COMANDO GIT ADD É UTILIZADO) DESDE O ÚLTIMO COMMIT.

	-> GIT CHECKOUT HEAD -- <caminho/arquivo>
	ESSE COMANDO PERMITE DESFAZER AS ALTERAÇÕES DESDE O ÚLTIMO COMMIT, INCLUÍNDO O STAGE (A ALTERAÇÃO ACONTECE QUANDO O COMANDO GIT ADD É UTILIZADO).


=============================================================================================
--- GIT REVERT ---
	
	OUTRO COMANDO UTILIZANDO PARA DESFAZER. ESSE COMANDO IRÁ CRIAR UM NOVO COMMIT, DESFAZENDO TODAS AS ALTERAÇÕES ATÉ O COMMIT ESPECIFICADO. PARA QUE O COMANDO SEJA UTILIZADO, PRIMEIRO DEVEMOS SABER QUAL O CÓDIGO DO COMMIT QUE QUEREMOS RETORNAR. UMA FORMA DE CONSEGUIR ESSE CÓDIGO É UTILIZANDO O COMANDO GIT LOG. O RETORNO SERÁ DOS ÚLTIMOS COMMITS ENVIADOS. E COM A POSSE DESSE CÓDIGO, BASTA UTILIZAR O COMANDO:
	-> GIT REVERT <código commit>

	NÃO HÁ A NECESSIDADE DE COPIAR O CÓDIGO POR COMPLETO. NA MÉDIA, 6 CARACTERES SÃO SUFICIENTES PARA O COMMIT SER ENCONTRADO, POIS CADA CÓDIGO DESSES É ÚNICO.

=============================================================================================
--- GIT DIFF ---
	
	ESSE É OUTRO COMANDO DO GIT BASTANTE INTERESSANTE DE UTILIZAR. O RETORNO QUE ESSE COMANDO TRÁS É A DIFERENÇA ENTRE DOIS COMMITS. PARA UTILIZAR ESSE COMANDO É NECESSÁRIO POSSUIR DOIS CÓDIGOS DE DOIS COMMITS DIFERENTES. PARA ACESSAR ESSES CÓDIGOS UMA MANEIRA É UTILIZAR O GIT LOG.
	-> GIT DIFF <código commit1> <código commit2>

	O RETORNO IRÁ MOSTRAR AS DIFERENÇAS ENTRE OS COMMITS.

=============================================================================================
--- GIT RESET ---

	ESTE É UM COMANDO VERSÁTIL E ÚTIL. MAS DEVE SER USADO COM CUIDADO. HÁ ALGUMAS FORMAS DE UTILIZAR ELE. BASICAMENTE VOCÊ PODE UTILIZAR O RESET E O RESET --HARD PARA DESFAZER TODAS AS ALTERAÇÕES LOCAIS QUE VOCÊ FEZ E VOLTAR OS ARQUIVOS PARA O ESTADO INICIAL DO PUSH. ENTRETANTO, SE VOCÊ ADICIONAR O CÓDIGO DO COMMIT, O COMANDO IRÁ APAGAR OS COMMITS FEITOS DEPOIS DELE. E OUTRAS PESSOAS OU EMPRESAS PODEM ESTAREM USANDO ESSES ARQUIVOS E ISSO PODE TRAZER GRANDES PROBLEMAS. MAS, PARA O INICIANTE, APENAS O COMANDO:
	-> GIT RESET (--HARD)

	:É UM BOM COMANDO PARA VOLTAR OS ARQUIVOS ATÉ O PONTO INICIAL DO PUSH. PARA RESETAR REPOSITÓRIOS E REMOVER TODAS AS ALTERAÇÕES É MELHOR APROFUNDAMENTO TÉCNICO SOBRE O COMANDO.

=============================================================================================
--- BRANCHING ---
	
	* RAMIFICAÇÕES *
	BRANCH NADA MAIS É DO QUE UMA RAMIFICAÇÃO DO CÓDIGO QUE ESTÁ SENDO CONSTRUÍDO. POR PADRÃO, A PRINCIPAL BRANCH É A MASTER. UM MESMO PROJETO PODE TER DIFERENTES BRANCHS. UTILIZANDO O COMANDO:
	-> GIT BRANCH

	:VOCÊ PODERÁ VISUALIZAR TODAS AS BRANCHS DISPONÍVEIS. OBS: FIQUE ATENTO, POIS ESSE COMANDO TRÁS A INFORMAÇÃO DE FORMA 'LOCAL'. E PARA TER TODAS AS BRANCHS EM UTILIZAÇÃO TALVEZ SEJA NECESSÁRIO DAR O GIT PULL PARA AS INFORMAÇÕES SEREM MAIS CORRETAS. O RETORNO SERÁ TODAS AS BRANCHS EXISTENTES.
	HÁ AINDA OUTROS COMANDOS QUE PODEM SER UTILIZADOS, COMANDOS ESSES DERIVADOS DO GIT BRANCH. HÁ:
	-> GIT BRANCH <nova_branch>

	QUE COMO ESPERADO, CRIA UMA NOVA BRANCH A PARTIR DA BRANCH ATUAL. HÁ UMA FORMA DE EXCLUIR A BRANCH, UTILIZANDO O COMANDO:
	-> GIT BRANCH -D <branch>

	ESSE COMANDO IRÁ EXCLUIR A BRANCH, ENTÃO DEVE SER USADO COM CAUTELA E CERTEZA DE QUE A EXCLUSÃO PODE SER FEITA.

	PS: APÓS A CRIAÇÃO DE UMA NOVA BRANCH, OU A QUALQUER MOMENTO QUE VOCÊ DESEJE MUDAR A BRANCH EM QUE VOCÊ ESTEJA TRABALHANDO, VOCÊ PODERÁ UTILIZAR O COMANDO:
	-> GIT CHECKOUT <branch>

	ESSE COMANDO IRÁ TE COLOCAR NA BRANCH ESPECIFICADA. O RETORNO SERÁ A CONFIRMAÇÃO QUE VOCÊ FEZ A TROCA DE BRANCH. E A PARTIR DE AGORA, TODOS OS COMMITS QUE FOREM FEITOS, SERÃO FEITOS NESSA BRANCH E NÃO MAIS NA ANTIGA.

	COM A CRIAÇÃO DE UMA NOVA BRANCH, ALGUNS COMANDOS IRÃO TRAZER RETORNOS DIFERENTES; UM DELES É O GIT LOG.
=============================================================================================
--- GIT MERGE ---
	
	UM DOS COMANDOS MAIS COMPLEXOS ATÉ O MOMENTO. O MERGE SERVE PARA UNIR DUAS DIFERENTES BRANCHS. O MERGE IRÁ PEGAR UMA BASE COMUM ENTRE AS DUAS BRANCHS E APLICAR TODOS OS COMMITS QUE A BRANCH ATUAL NÃO POSSUI. CASO VOCÊ TENHA DUAS BRANCHS ('A' E 'B'), SENDO A 'B' A ÚLTIMA UTILIZADA; O MERGE TRARÁ TODOS OS COMMITS DE 'B' PARA 'A', ATUALIZANDO ASSIM A BRANCH 'A'. ENTRETANTO, SE NA SUA BRANCH 'A', VOCÊ FEZ COISAS QUE NÃO EXISTEM NA BRANCH 'B', SERÁ CRIADO UM COMMIT DE MERGE. PARA UTILIZAR O MERGE BASTA UTILIZAR O SEGUINTE COMANDO:
	-> GIT MERGE <branch>

	UTILIZANDO ESSE COMANDO É ESPERADO QUE HAJAM CONFLITOS NOS ARQUIVOS. O DESENVOLVEDOR DEVERÁ RESOLVER ESSES CONFLITOS. RESOLVIDO TODOS OS CONFLITOS, SERÁ CRIADO UM COMMIT DE MERGE.
=============================================================================================
--- GIT REBASE ---

	SEGUINDO NOS COMANDOS COMPLEXOS, TEMOS O REBASE. O REBASE É SEMELHANTE AO MARGE, PORÉM A DIFERENÇA FICA NA ORDEM DE APLICAR OS COMMITS. COM O REBASE, OS COMMITS NA FRENTE DA BASE SÃO REMOVIDOS TEMPORARIAMENTE, ENTÃO SÃO APLICADOS OS COMMITS DA OUTRA BRANCH E POR FIM, OS COMMITS QUE FORAM REMOVIDOS, SERÃO APLICADOS.
	TALVEZ SEJA NECESSÁRIO RESOLVER CONFLITOS.

